*********************************************************** Java Collections ************************************************************

List - збереження послідовності елементів
Stack
Queue
Dequeue
Set (множина) - забезпечує унікальність значення для кожного типу
Map(карта, асоціативний масив)

----------
Lection11
YaremkoS_P3
YaremkoS_H3
YaremkoS_Pr5

***

http://www.javatpoint.com/collections-in-java
https://habrahabr.ru/post/182776/

https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html

https://proglib.io/p/google-guide-for-studying/
-----------
Java SE (Standard Edition):
                            This is the core Java programming platform. It contains all of the libraries and APIs that any Java programmer should learn (java.lang, java.io, java.math, java.net, java.util, etc...).

Java EE (Enterprise Edition):
                            The Java platform (Enterprise Edition) differs from the Java Standard Edition Platform (Java SE) in that it adds libraries which provide functionality to deploy fault-tolerant, distributed, multi-tier Java software, based largely on modular components running on an application server.

                            Built on top of Java SE, it provides libraries for database access (JDBC, JPA), remote method invocation (RMI), messaging (JMS), web services, XML processing, and defines standard APIs for Enterprise JavaBeans, servlets, portlets, Java Server Pages, etc...
Java ME (Micro Edition):
                            his is the platform for developing applications for mobile devices and embedded systems such as set-top boxes. Java ME provides a subset of the functionality of Java SE, but also introduces libraries specific to mobile devices. Because Java ME is based on an earlier version of Java SE, some of the new language features introduced in Java 1.5 (e.g. generics) are not available.
-------------------------------------------------------------------------------------------------------------------------------------
Параметризовані типи (generics) - класи, які компілятор може автоматично адаптувати для роботи з визначеними типами.

The collections framework

The collections framework is a unified architecture for representing and manipulating collections, enabling them to be manipulated independently of the details of their representation. It reduces programming effort while increasing performance. It enables interoperability among unrelated APIs, reduces effort in designing and learning new APIs, and fosters software reuse. The framework is based on more than a dozen collection interfaces. It includes implementations of these interfaces and algorithms to manipulate them.

All collections frameworks contain the following:

Interfaces: These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy.
Implementations: These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures.
Algorithms: These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be polymorphic: that is, the same method can be used on many different implementations of the appropriate collection interface. In essence, algorithms are reusable functionality.

Інтероперабельність – здатність різних програм, систем та мереж до ефективної спільної роботи, обміну інформацією та її використання – стала такою ж важливою характеристикою програмного забезпечення, як надійність та безпека.

В Java існує кілька способів зберігання об'єктів:
    Масиви:
            1. У масивах об'єктах призначаються числові індекси. 
            2. Масив містить об'єкти заздалегідь відомого типу, тому перетворення типу при вибірці об'єкта не потрібно проводити.  
            3. Масив може бути багатовимірним і може використовуватися для зберігання примітивних типів. 
            4. Проте змінити розмір створеного масиву неможливо.

            Students[] list=new Students[4];
            int [] i = new int[4];
    Collection: Collection represents a single unit of objects i.e. a group.
            1. У Collection зберігаються окремі елементи, а в Mар - пари асоційованих елементів. 
            2. Механізм параметризації дозволяє задати тип об'єктів, що зберігаються в контейнері, тому помістити в контейнер об'єкт невірного типу неможливо, і елементи не потребують перетворення типу при вибірці. 
            3. І Collection, і Map автоматично змінюються в розмірах при додаванні нових елементів. 
            4. У контейнерах не можуть зберігатися примітиви, але механізм автоматичної упаковки автоматично створює об'єктні «обгортки», які зберігаються в контейнері.

            5. У контейнері List, як і в масиві, об'єктам призначаються числові індекси - таким чином, масиви і List є впорядкованими контейнерами.
            6. Використовуйте ArrayList при частому використанні довільного доступу до елементів або LinkedList при частому виконанні операцій вставки і видалення в середині списку.
            7. Поведінка Queue Deque Stack забезпечується контейнером LinkedList.

           8. Контейнер Map пов'язує з об'єктом не цілочисельний індекс, а інший об'єкт. 
           9. Контейнери HashMap оптимізовані для швидкого доступу, 
              а контейнер ТгееМар зберігає ключі в відсортованому порядку, але поступається за швидкістю HashMap. 
              У контейнері LinkedHashMap елементи зберігаються в порядку вставки, але Хешування забезпечує швидкий доступ.

            10. У контейнері Set кожен об'єкт може зберігатися тільки в одному екземплярі. 
            11. Контейнер HashSet забезпечує максимальну швидкість пошуку, 
                а в TreeSet елементи зберігаються в відсортованому порядку. 
                У контейнері LinkedHashSet елементи зберігаються в порядку вставки.
            12. Використовувати старі класи Vector, Stack і Hashtable в новому коді не потрібно.


Бібліотека утиліт Java (java.util .*) також містить достатньо повний набір класів контейнерів (також відомих, як класи колекцій, але, оскільки ім'я Collection (колекція) використовується для позначення певної підмножини бібліотеки Java, я буду вживати загальний термін «контейнер») . 
Директива ©SuppressWarnings для придушення попереджень. 

2 базових інтерфейси бібліотеки java.util.*:
    * Collection (Колекція) - група окремих елементів, сформована за деякими правилами:

                Клас List (список) зберігає елементи в порядку вставки, 
                в класі Set (множина) не можна зберігати повторювані елементи, 
                а клас Queue (черга) видає елементи в порядку, визначеному специфікою черги (зазвичай це порядок вставки елементів в чергу).

                (* Queue - FIFO - first in first out 
                 * Stack - LIFO - last in first out)

        Інтерфейс Collection представляє концепцію послідовності як способу зберігання групи об'єктів

    * Map (Карта) - набір пар об'єктів «ключ-значення», з можливістю вибірки по ключу. 

                ArrayList дозволяє шукати об'єкти за номером, тому в якомусь сенсі він пов'язує числа з об'єктами. 
                Клас Map (карта - також зустрічаються терміни асоціативний масив і словник) дозволяє шукати об'єкти по інших об'єктах - наприклад, отримати об'єкт значення по об'єкту ключа, за аналогією з пошуком визначення по слову.

                                                                *** deep copy vs shallow copy ***

Shallow copies duplicate as little as possible. A shallow copy of a collection is a copy of the collection structure, not the elements. With a shallow copy, two collections now share the individual elements.

Deep copies duplicate everything. A deep copy of a collection is two collections with all of the elements in the original collection duplicated.

                                                            *** Додавання груп елементів ***

Сімейства Arrays і Collections в java.util містять допоміжні методи для включення груп елементів в колекції. 
Метод Arrays.asList () отримує або масив, або список елементів, розділених комами, і перетворює його на об'єкт List.
      Arrays.toString() 
Метод Collections.addAll() отримує об'єкт Collection і або масив, або список, розділений комами, і додає елементи в Collection.

-------------------------------------------------------------------------------------------------------------------------------
***
Collection vs Collections
***

First of all, "Collection" and "Collections" are two different concepts.
 "Collection" is a root interface in the Collection hierarchy
 "Collections" is a class which provide static methods to manipulate on some Collection types.

                                                                  ***
                                                                  Array
                                                                  ***

Масив — це структура даних, що являє собою однорідну, фіксовану по розміру й конфігурації сукупність елементів простої або складеної структури, упорядкованих по номерах.
Масив визначається ім'ям (ідентифікатором) і кількістю розмірностей (координат), необхідних для вказівки місцезнаходження необхідного елемента масиву. 
Ім'я масиву є єдиним для всіх його елементів.

Оскільки конфігурація елементів масиву фіксована, то до окремого елемента можна звертатися за допомогою одного або декількох індексів, залежно від кількості розмірностей масиву. 
Елементами масивів можуть бути як змінні примітивних типів, так і екземпляри класів.
Як правило, використаються одномірні, двомірні й тривимірні масиви. 
Масиви більшої розмірності на практиці зустрічаються рідко.




                                                                  ***
                                                                  List
                                                                  ***


List<Type> testList = new ArrayList<Type>();

An ordered collection (also known as a sequence). The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list.
Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare.

Контейнери List гарантують певний порядок проходження елементів.
Інтерфейс List доповнює Collection кількома методами, що забезпечують вставку і видалення елементів в середині списку.

Collection different methods:

    void    add(int index, E element) - Inserts the specified element at the specified position in this list (optional operation).
    boolean addAll(int index, Collection<? extends E> c) - Inserts all of the elements in the specified collection into this list at the specified position (optional operation).
    E get(int index) - Returns the element at the specified position in this list.
    E remove(int index) - Removes the element at the specified position in this list (optional operation).
    default void sort(Comparator<? super E> c) - Sorts this list according to the order induced by the specified Comparator.
    int indexOf(Object o) - Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element.

Існує дві основні різновиди List:
Базовий контейнер ArrayList, оптимізований для довільного доступу до елементів, але з відносно повільними операціями вставки(видалення) елементів в середині списку.

Контейнер LinkedList, оптимізований для послідовного доступу, з швидкими операціями вставки (видалення) у середині списку;
Довільний доступ до елементів LinkedList виконується відносно повільно, але по широті можливостей він перевершує ArrayList.


    ArrayList:
                + час вибору будь-якого елемента незмінний

    Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)

        Methods:

               (Collection) removeIf(Predicate<? super E> filter) - Removes all of the elements of this collection that satisfy the given predicate.
                removeRange(int fromIndex, int toIndex) - Removes from this list all of the elements whose index is between fromIndex,  inclusive, and toIndex, exclusive.
                ensureCapacity(int minCapacity) - Increases the capacity of this ArrayList instance, if necessary, to ensure that it can hold at least the number of elements specified by the minimum capacity argument.
                size() - к-сть елементів у списку


                

    LinkedList (методи Stack Queue Deque)
                - не вигідно працювати з довільним доступом:
                    чим далі по списку, тим більший час знаходження елемента
                + швидка вставка всередину списку

         Methods:

            getFirst () | element () ідентичні - вони повертають початок (перший елемент) списку без його видалення і видають виняток NoSuchElementException для порожнього списку. 
            peek() представляє собою невелику модифікацію цих двох методів: він повертає null для порожнього списку.
            peekFirst() - Retrieves, but does not remove, the first element of this list, or returns null if this list is empty.
            peekLast() - Retrieves, but does not remove, the last element of this list, or returns null if this list is empty.
            poll() - Retrieves and removes the head (first element) of this list.or returns null if this list is empty.
            pollFirst() - Retrieves and removes the first element of this list, or returns null if this list is empty.
            pollLast() - Retrieves and removes the last element of this list, or returns null if this list is empty.
            getLast() - Returns the last element in this list.
            addFirst() вставляє елемент на початок списку. 
            addLast() - Appends the specified element to the end of this list.
            offer() робить те саме, що add() і addLast() - він додає елемент в кінець списку. 
            offerFirst(E e) - Inserts the specified element at the front of this list.
            offerLast(E e) - Inserts the specified element at the end of this list.
            remove() -  removes the head (first element) of this list.
            E remove(int index) - Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.
            removeFirst() - Removes and returns the first element from this list.
            removeLast() видаляє і повертає останній елемент списку.

             *** like Queue ***
            peek() - Retrieves, but does not remove, the head (first element) of this list.: він повертає null для порожнього списку.
            element() - Retrieves, but does not remove, the head (first element) of this list: видають виняток NoSuchElementException для порожнього списку. 
            poll() -  Retrieves and removes the head (first element) of this list.or null if this list is emptyor null if this list is empty
            remove() - Retrieves and removes the head (first element) of this list.NoSuchElementException - if this list is empty
            offer() робить те саме, що add() і addLast() - він додає елемент в кінець списку. 
            removeFirstOccurrence() - Removes the first occurrence of the specified element in this list (when traversing the list from head to tail). If the list does not contain the element, it is unchanged.
            Returns:
            true if the list contained the specified element
            removeLastOccurrence() - Removes the last occurrence of the specified element in this list (when traversing the list from head to tail). If the list does not contain the element, it is unchanged.
            Returns:
            true if the list contained the specified element


            *** like Deque ***
            getFirst () | element () ідентичні - вони повертають початок (перший елемент) списку без його видалення і видають виняток NoSuchElementException для порожнього списку. 
            getLast() - Returns the last element in this list.
            addFirst() вставляє елемент на початок списку. 
            addLast() - Appends the specified element to the end of this list.
            removeFirst() - Removes and returns the first element from this list.
            removeLast() видаляє і повертає останній елемент списку.
            offerFirst(E e) - Inserts the specified element at the front of this list.
            offerLast(E e) - Inserts the specified element at the end of this list.
            peekFirst() - Retrieves, but does not remove, the first element of this list, or returns null if this list is empty.
            peekLast() - Retrieves, but does not remove, the last element of this list, or returns null if this list is empty.
             pollFirst() - Retrieves and removes the first element of this list, or returns null if this list is empty.
            pollLast() - Retrieves and removes the last element of this list, or returns null if this list is empty.

            peek() - Retrieves, but does not remove, the head (first element) of this list.: він повертає null для порожнього списку.
            element() - Retrieves, but does not remove, the head (first element) of this list: видають виняток NoSuchElementException для порожнього списку. 
            poll() -  Retrieves and removes the head (first element) of this list.or null if this list is empty
            remove() - Retrieves and removes the head (first element) of this list.NoSuchElementException - if this list is empty
            offer() робить те саме, що add() і addLast() - він додає елемент в кінець списку. 
            Iterator<E> descendingIterator() - Returns an iterator over the elements in this deque in reverse sequential order.
            Returns: an iterator over the elements in this deque in reverse sequence



            *** like Stack ***
            peek() - Retrieves, but does not remove, the head (first element) of this list.: він повертає null для порожнього списку.
            pop() - Pops an element from the stack represented by this list. In other words, removes and returns the first element of this list.
            push(E e) - Pushes an element onto the stack represented by this list. In other words, inserts the element at the front of this list.



                                                                 ***
                                                                 Stack 
                                                                 ***
Stack часто називають контейнером, що працюють за принципом «першим увійшов, останнім вийшов» (LIFO). Тобто елемент, останнім занесений в стек, буде першим, отриманим при витяганні з стека.

A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class. 

У класі LinkedList є методи, що безпосередньо реалізують функціональність стека, тому ви просто використовуєте LinkedList, не створюючи для стека новий клас. 

        Methods:
           E peek() - Looks at the object at the top of this stack without removing it from the stack.
                     EmptyStackException - if this stack is empty.
           E push(E item) - Pushes an item onto the top of this stack.
           E pop() - Removes the object at the top of this stack and returns that object as the value of this function.
                    EmptyStackException - if this stack is empty.
           int search(Object o) - Returns the 1-based position where an object is on this stack. If the object o occurs as an item in this stack, this method returns the distance from the top of the stack of the occurrence nearest the top of the stack; the topmost item on the stack is considered to be at distance 1. The equals method is used to compare o to the items in this stack.

                                                                 ***
                                                                Interface Queue (Черга) 
                                                                 ***

A collection designed for holding elements prior to processing. 
Besides basic Collection operations, queues provide additional insertion, extraction, and inspection operations.
 Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation).
The latter form of the insert operation is designed specifically for use with capacity-restricted Queue implementations; in most implementations, insert operations cannot fail.

Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner. 
Among the exceptions are priority queues, which order elements according to a supplied comparator, or the elements' natural ordering, 
and LIFO queues (or stacks) which order the elements LIFO (last-in-first-out).
 Whatever the ordering used, the head of the queue is that element which would be removed by a call to remove() or poll(). 
 In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules.
 Every Queue implementation must specify its ordering properties.

 Queue - FIFO - first in first out 

Черга звичайно являє собою контейнер, що працює за принципом «першим увійшов, першим вийшов» (FIFO). 
Черги часто застосовуються для реалізації надійної передачі об'єктів між різними областями програми.
Клас LinkedList містить методи, які підтримують поведінку черги, і реалізує інтерфейс Queue, тому LinkedList може використовуватися в якості реалізації Queue. 
У наступному прикладі LinkedList підвищується висхідним перетворенням до Queue:


       Throws exception    Returns special value (null/false)
Insert   add(e)                offer(e)
Remove   remove()               poll()
Examine  element()              peek()

                                                                 ***
                                                                Interface Deque extens Queue
                                                                 ***

A linear collection that supports element insertion and removal at both ends.
The name deque is short for "double ended queue" and is usually pronounced "deck". 
Most Deque implementations place no fixed limits on the number of elements they may contain, but this interface supports capacity-restricted deques as well as those with no fixed size limit.

Summary of Deque methods

                 First Element (Head)               Last Element (Tail)
         Throws exception    Special value   Throws exception    Special value
Insert    addFirst(e)         offerFirst(e)    addLast(e)          offerLast(e)
Remove    removeFirst()       pollFirst()      removeLast()        pollLast()
Examine   getFirst()          peekFirst()      getLast()           peekLast()

When a deque is used as a queue, FIFO (First-In-First-Out) behavior results.

Comparison of Queue and Deque methods

Queue Method    Equivalent Deque Method
add(e)          addLast(e)
offer(e)        offerLast(e)
remove()        removeFirst()
poll()          pollFirst()
element()       getFirst()
peek()          peekFirst()

Deques can also be used as LIFO (Last-In-First-Out) stacks. This interface should be used in preference to the legacy Stack class. When a deque is used as a stack, elements are pushed and popped from the beginning of the deque. Stack methods are precisely equivalent to Deque methods as indicated in the table below:

Comparison of Stack and Deque methods

Stack Method    Equivalent Deque Method
push(e)          addFirst(e)
pop()            removeFirst()
peek()           peekFirst()                                                               


                                                                 ***
                                                                 Set (Множина) - швидкий пошук
                                                                 ***

A collection that contains no duplicate elements. More formally, sets contain no pair of elements e1 and e2 such that e1.equals(e2), and at most one null element. As implied by its name, this interface models the mathematical set abstraction.

!!! Отже, найважливішою операцією Set є операція пошуку, тому на практиці звичайно вибирається реалізація HashSet, оптимізована для швидкого пошуку.

У множинах (Set) кожне значення може зберігатися тільки в одному екземплярі. 
Спроби додати новий екземпляр еквівалентного об'єкта блокуються. 
Множини часто використовуються для перевірки приналежності, щоб ви могли легко перевірити, чи належить об'єкт заданій множині. 
Отже, найважливішою операцією Set є операція пошуку, тому на практиці звичайно вибирається реалізація HashSet, оптимізована для швидкого пошуку.

Якщо ви хочете, щоб результат був відсортований, скористайтесь TreeSet замість HashSet

Однією з найбільш поширених операцій з множинами є перевірка приналежності методом contains()

*** HashSet<E> ***

This class implements the Set interface, backed by a hash table (actually a HashMap instance).

This class offers constant time performance for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets. 
Iterating over this set requires time proportional to the sum of the HashSet instance's size (the number of elements) plus the "capacity" of the backing HashMap instance (the number of buckets). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.

*** TreeSet<E> ***

A NavigableSet implementation based on a TreeMap.

The elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used.

This implementation provides guaranteed log(n) time cost for the basic operations (add, remove and contains).

                                                                ***
                                                                 Map
                                                                ***

An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value.

                                                                ***
                                                                HashTable
                                                                ***

!!!!!!!!!!! Thread-saved and doesn't allow null-keys and null-values
This class implements a hash table, which maps keys to values. Any non-null object can be used as a key or as a value.
To successfully store and retrieve objects from a hashtable, the objects used as keys must implement the hashCode method and the equals method.


*** HashMap ***

!!!!!!!!!!! Thread-unsaved and  allows null-keys and null-values

Hash table based implementation of the Map interface. 

This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.)

This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the "capacity" of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.

*** TreeMap ***

A Red-Black tree based NavigableMap implementation. The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.

This implementation provides guaranteed log(n) time cost for the containsKey, get, put and remove operations. Algorithms are adaptations of those in Cormen, Leiserson, and Rivest's Introduction to Algorithms.




                                                                 ***
                                                                 Bag (Мішок)
                                                                 ***

public class Bag<Item> implements Iterable<Item>
Bag()
створює порожній мішок
void add(Item x)
додає новий елемент в мішок
int size()  
кількість елементів в мішку
Iterable<Item> iterator()
ітератор по елементам
Реалізація: Стек без pop або черга без dequeue
public class Bag<Item> implements Iterable<Item>
Bag()
створює порожній мішок
void add(Item x)
додає новий елемент в мішок
int size()  
кількість елементів в мішку
Iterable<Item> iterator()
ітератор по елементам
Реалізація: Стек без pop або черга без dequeue




                                                               
                
Корисні методи:

add(Object o);
remove(Object o);
remove(int i);
indexOf(Object o);
subList(int i, int j);
contains(Object o);
containsAll(List l);
Collections.sort(List l);
removeAll(List l);
set(int I, Object o);
addAll(int i, List l);

                                                    *** 
                                                    Map 
                                                    ***

Контейнери легко комбінуються один з одним, що дозволяє швидко створювати складні структури даних. 
Наприклад, якщо нам буде потрібно зберегти інформацію про власників відразу декількох домашніх тварин, для цього буде достатньо створити контейнер Map <Person, List <Pet>>:

                                            *** Ітератор (Iterator) ***

Якщо ви хочете написати універсальний код, який не залежить від типу контейнера і може застосовуватися до будь-якого контейнера?

Ітератор - це об'єкт, що забезпечує переміщення по послідовності об'єктів з вибором кожного об'єкта цієї послідовності, при цьому програмісту-клієнтові не треба знати або піклуватися про те що лежить в основі структури. 
До того ж, ітератор зазвичай є так званим «легковажним» (light-weight) об'єктом: його створення має обходитися без помітних витрат ресурсів. 
Через це ітератори часто мають обмеження, наприклад, Iterator в Java підтримує переміщення тільки в одному напрямку. 

Можливості:
            * Запитати у контейнера ітератор викликом методу iterator(). Отриманий ітератор готовий повернути початковий елемент послідовності при першому виклику свого методу next ().

            * Отримати наступний елемент послідовності викликом методу next().

            * Перевірити, чи залишилися ще об'єкти в послідовності (метод hasNext ()).

            * Видалити з послідовності останній елемент, повернутий ітератором, методом remove().

***
Interface Iterable<T> - інтерфейс, що має методи:

                        Iterator<T> iterator(); - Returns an iterator over elements of type T.

Usage:

1. Дозволяє скористатися циклом foreach:

    for (String str : myStack) {
        System.out.println(str + '\n');
                                }
! All the dirty work of creating the Iterator<String>, checking if it hasNext(), and calling str = getNext() is handled behind the scenes by the compiler:

    Iterator<String> itr = myStack.iterator();
    while (itr.hasNext()){
            String s = itr.next();
            System.out.println(s + '\n');
                         }

Interface Iterator<T> - інтерфейс, що має методи:
            
                        1. boolean hasNext();
                        2. T next();
                        3. void remove();

An iterator over a collection. Iterator takes the place of Enumeration in the Java Collections Framework. Iterators differ from enumerations in two ways:
Iterators allow the caller to remove elements from the underlying collection during the iteration with well-defined semantics.
Method names have been improved.

Interface Enumeration<E>

NOTE: The functionality of this interface is duplicated by the Iterator interface. In addition, Iterator adds an optional remove operation, and has shorter method names. New implementations should consider using Iterator in preference to Enumeration.

1. boolean hasMoreElements() - Tests if this enumeration contains more elements.

2. E nextElement() - Returns the next element of this enumeration if this enumeration object has at least one more element to provide.

                                                        *** ListIterator ***

ListIterator – потужніший різновид ітератора (Iterator), що підтримується лише класами List. 
Якщо Iterator підтримує переміщення тільки вперед, ListIterator є двостороннім. 
Крім того, він може видавати індекси наступного і попереднього елементів по відношенню до поточної позиції ітератора в списку і замінювати останній відвіданий елемент методом set(). 
Виклик listIterator() повертає ListIterator, який вказує на початок List, а для створення ітератора ListIterator, спочатку встановленого на елемент з індексом n, використовується виклик listIterator(n). 

                                                        *** Comparable vs Comparator ***

Interface Comparable<T> and Interface Comparator<T> - упорядковують елементи:

            * Interface Comparable<T> - забезпечує наявність ОДНОГО виду сортування
            * Interface Comparator<T> - забезпечує наявність ДЕКІЛЬКОХ видів сортування

                                                        ***  Interface Comparable<T> ***

 * Interface Comparable<T> - забезпечує наявність ОДНОГО виду сортування

 This interface imposes a total ordering on the objects of each class that implements it. 
 This ordering is referred to as the class's natural ordering, 
 and the class's compareTo method is referred to as its natural comparison method.

Lists (and arrays) of objects that implement this interface can be sorted automatically by Collections.sort (and Arrays.sort). 
Objects that implement this interface can be used as keys in a sorted map or as elements in a sorted set, without the need to specify a comparator.

int compareTo(T o) - Compares this object with the specified object for order.

Returns:
a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.

public interface Comparable<Type>{
    public int compareTo(Type item);
}

int res = x.compareTo(y) =>
                            res > 0 ( res == 1 ) => x > y
                            res == 0 => x == y
                            res < 0 ( res == -1 ) => x < y

Example:

public class Students implements Comparable {

    protected String name;
    protected int age;

    public Students(String name, int age) {

        this.name = name;
        this.age = age;

    }

    public String getName() {
        return name;
    }

    
    public int getAge() {
        return age;
    }


    @Override
    public String toString() {
        return name + " " + age;
    }

    public int compareTo(Object obj) {
        Students people = (Students) obj;

        int result = name.compareTo(people.name);
        if (result != 0) {
            return result;
        }

        result = age - people.age;
        if (result != 0) {
            return (int) result / Math.abs(result);
        }
        return 0;
    }

}
         
Usage:

Students [] stds = new Students[4];
Integer [] keys = new Integer[4];

Arrays.sort(stds);

MergeSort.sort(stds,keys);
InsertionSort.sort(stds, keys);
SelectionSort.sort(stds,keys);
ShellSort.sort(stds,keys);      
                                

                                                                ***  Interface Comparator<T> ***

* Interface Comparator<T> - забезпечує наявність ДЕКІЛЬКОХ видів сортування

  Comparator<T> у своєму методі сортування compare()  використовує compareTo()

  int compare(T o1, T o2) - Compares its two arguments for order.

A comparison function, which imposes (накладати) a total ordering on some collection of objects. 
Comparators can be passed to a sort method (such as Collections.sort or Arrays.sort) to allow precise control over the sort order. Comparators can also be used to control the order of certain data structures (such as sorted sets or sorted maps), 
or to provide an ordering for collections of objects that don't have a natural ordering.

Unlike Comparable, a comparator may optionally permit comparison of null arguments, while maintaining the requirements for an equivalence relation.

public interface Comparator<Type>{
    public int compare (Type x, Type y);
}

Example:
--------

        public class Students implements Comparable<Students>{

            public int compareTo(Students std){
                //realisation
            }

            public static final Comparator<Students> SORTED_BY_NAME = new SortedByName();
            public static final Comparator<Students> SORTED_BY_AGE = new SortedByAge);

            private static class SortedByName implements Comparator<Students>{

                public int compare (Students std1, Students std2){
                return std1.getName().compareTo(std2.getName());

                }
            }

            private static class SortedByAge implements Comparator<Students>{

                public int compare (Students std1, Students std2){
                return std1.getAge().compareTo(std2.getAge());

                }
            }
        }

Usage:

Students [] stds = new Students[4];

Arrays.sort(stds);
Arrays.sort(stds, Students.SORTED_BY_NAME);
Arrays.sort(stds, Students.SORTED_BY_AGE);
Collections.sort(stds, Students.SORTED_BY_NAME);
Collections.sort(stds, Students.SORTED_BY_AGE);       

EXAMPLE:

public class Students implements Comparable<Students> {
    private String name;
    private Integer age;

    public Students(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    public static final Comparator<Students> BY_NAME = new SortedByName();

    public static final Comparator<Students> BY_AGE = new SortedByAge();

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    /*
     * public void setAge(Integer age) { this.age = age; }
     */

    public String toString() {
        return name + " " + age + "\n";
    }

    private static class SortedByName implements Comparator<Students> {

        public int compare(Students st1, Students st2) {
            return st1.name.compareTo(st2.name);

        }
    }

    private static class SortedByAge implements Comparator<Students> {

        public int compare(Students st1, Students st2) {

            return st1.age.compareTo(st2.age);

        }
    }

    public int compareTo(Students st) {
        Students people = st;

        int result = name.compareTo(people.name);
        if (result != 0) {
            return result;
        }

        result = age - people.age;
        if (result != 0) {
            return (int) result / Math.abs(result);
        }
        return 0;
    }
    
}

Students [] stds = new Students[4];
Integer [] keys = new Integer[4];

// Use Comparable
Arrays.sort(stds);

//Use Comparator
Arrays.sort(stds, Students.SORTED_BY_NAME);
Arrays.sort(stds, Students.SORTED_BY_AGE);
Collections.sort(stds, Students.SORTED_BY_NAME);
Collections.sort(stds, Students.SORTED_BY_AGE);       

 MergeSort.sort(stds, keys, Students.BY_AGE);
 InsertionSort.sort(stds, keys, Students.BY_AGE);
 SelectionSort.sort(stds, keys, Students.BY_AGE);
 ShellSort.sort(stds, keys, Students.BY_AGE);

 MergeSort.sort(stds, keys, Students.BY_NAME);
 InsertionSort.sort(stds, keys, Students.BY_NAME);
 SelectionSort.sort(stds, keys, Students.BY_NAME);
 ShellSort.sort(stds, keys, Students.BY_NAME);

    ***

 Структури даних/ Контейнери/колекції (data structures):

 Array
 List
 Bag
 Stack
 Queue
 PriorityQueue - видаляэмо найбільший/найменший елемент
 BT(Binary Search Tree) - порожнє, або вузол з лінками на праве і ліве бінарне дерево
                        - это структура данных, которая имеет корень и определенное количество детей, которые тоже могут иметь своих детей
 Повне бінарне дерево -  збалансоване дерево, окрім нижнього рівня
 Двійкова купа (англ. binary heap) — це структура даних, що є масивом, який можна розглядати як майже повне бінарне дерево. Кожен вузол цього дерева відповідає певному елементу масива. На всіх рівнях, крім, можливо останнього, дерево повністю заповнене (заповнений рівень — такий, що містить максимально можливу кількість вузлів). Останній рівень заповнюється послідовно зліва направо до тих пір, доки в масиві не закінчатся елементи
 Бінарна купа – представлення впорядкованої-купи повного бінарного дерева з використанням масиву.
 Бінарне дерево впорядкована купа:
 ключі в вузлах
 ключ батька має бути більшим за ключ сина
 HeapSort:
            Створюємо max-купу з усіма N елементами
            Повторюємо видалення максимального елемента поки не отримаємо відсортований масив


 Deque
 Set
 Map

 BST
 BBST (збалансовані)
 SPT (shortest-paths tree)
 hashtable - спосіб збереження даних

    ***

 Алгоритми сортування:
 
 bubble sort
 selection sort
 insertion sort
 shell sort
 merge sort
 quick sort
 !!!heapsort (опитимальний і по часу і по розміру):
            Створюємо max-купу з усіма N елементами
            Повторюємо видалення максимального елемента поки не отримаємо відсортований масив
 топологічне сортування - пошук працює на орієнтованих ациклічних графах 


 Алгоритми пошуку:
 
 BST (binary search tree /  ordered or sorted binary tree) - це двійкове дерево, для якого виконуються наступні умови:
                    обидва піддерева – ліве і праве є двійковими деревами пошуку
                    у всіх вузлів лівого піддерева довільного вузла Х значення ключів даних менше чим значення ключа даних самого вузла Х
                    у всіх вузлів правого піддерева того ж вузла Х значення ключів даних не менше чим значення ключа даних вузла Х

Збалансовані дерева пошуку:
                    2-3  BST
                    red-black BST
                    B-trees
 hash table

 Графи:

 Неорієнтований граф ( undirected graph ):
                         DFS ( Depth-first search )
                         BFS (Breadth-first search)
 Minimum spanning tree ( Мінімальне остове дерево) для неорієнтованого зваженого графа:
                         На вхід подається:
                                            неорієнтований граф G з ребрами, що мають цілі ваги
                                            остове дерево Т графа G є підграфом, що з’єднаний і ациклічний
                                            Ціль: знайти мінімальне за вагою остове дерево
                        Остове дерево - ациклічний зєднаний підграф графа
    Алгоритми знаходження (МОД):
                        Жадібний алгоритм (Quick-find)
                        Алгоритм Крускала (Kruskal)
                        !!! Алгоритм Прима (Prim)

Ейлеровий цикл  - цикл, що проходить через усі ребра неорієнтованого звязаного графа лише 1 раз.
Ейлеровим циклом у зв’язаному графі G називають цикл, який містить усі ребра графа.
Ейлеровим шляхом – ланцюг, що містить усі ребра графу.
Звязаний неорієнтований граф має ейлеровий цикл, коли степені всіх його вершин парні

Якщо граф має простий цикл, який містить усі вершини графу (по
одному разу), то такий цикл називається гамільтоновим циклом, а граф називається
гамільтоновим. Гамільтонів маршрут − це маршрут, який містить усі вершини графа по
одному разу.
Якщо для кожної вершини v зв’язаного простого графа з n ≥ 3
вершинами виконується нерівність d(v) ≥ n/2, то цей граф має гамільтонів цикл. 

 Орієнтований граф ( directed graph ):
                         DFS ( Depth-first search )
                         BFS (Breadth-first search)
                         топологічне сортування - пошук працює на орієнтованих ациклічних графах =>
                          => 
                          Вершини v і w є сильно зв’язаними (СЗ) якщо існує направлений шлях з v в w і з w в v.
                          Сильно зв’язаним компонентом називають максимальну підмножину сильно зв’язаних вершин
                          =>
                          Алгоритм Косараджу  - пошук сильно звязних компонентів за мін час:
                                                В алгоритмі використовується той факт, що транспонований орграф (той самий граф з оберненими напрямками ребер) має ті самі сильно зв’язані компоненти, що й початковий граф.
                                                    Основна ідея:
                                                    Обрахувати топологічну чергу в трансопонованому орграфі
                                                    Запустити DFS використовуючи топологічну чергу




SPT (shortest-paths tree) (деревом найкоротших шляхів ) для орієнтованого зваженого графа:
Визначення: для заданого ( орієнтованого зваженого графа )графа з зваженими ребрами і заданої вершини s деревом найкоротших шляхів для джерела s є підграф, що містить вершину s і всі досяжні з неї вершини, що утворюють орієнтоване дерево, з коренем в s , таке, що шлях в цьому дереві є найкоротшим шляхом в орграфі.

    Алгоритм Дейкстри (Edsger Dijkstra)

31.3. Задача комівояжера (комівояжер — бродячий торговець)
Розглянемо наступну задачу, відому як задача комівояжера. Маємо p міст, відстані
між якими відомі. Комівояжер повинен відвідати всі p міст по одному разу, повернувшись в
те, з якого почав. Потрібно знайти такий маршрут руху, при якому сумарна пройдена відстань
буде мінімальною.
Очевидно, що задача комівояжера – це задача пошуку найкоротшого гамільтонового
циклу в повному зваженому графі. Можна припустити наступну просту схему розв’язку
задачі комівояжера: згенерувати усі p! можливих перестановок вершин повного графа,
підрахувати для кожної перестановки довжину маршруту і обрати з них найкоротший.
Очевидно, таке обчислення потребує не менше О(p!) кроків.
Як відомо, p! – швидко зростаюча функція. Таким чином, розв’язок задачі комівояжера
описаним методом повного перебору виявляється практично неможливим навіть для
порівняно невеликих p. Більш того, відомо, що задача комівояжера належить до числа так
званих NP-повних задач. 

Прості методи розв'язання задачі комівояжера: повний лексичний перебір, жадібні алгоритми (метод найближчого сусіда), метод включення найближчого міста, метод найдешевшого включення, метод мінімального кістяка дерева. На практиці застосовують різні модифікації ефективніших методів: метод гілок і меж і метод генетичних алгоритмів, а так само алгоритм мурашиної колонії.

Всі ефективні (такі, що скорочують повний перебір) методи розв'язання задачі комівояжера — евристичні
У більшості евристичних методів знаходиться не найефективніший маршрут, а наближений розв'язок. 
Користуються популярністю так звані any-time алгоритми, тобто алгоритми, що поступово покращують деякий поточний наближений розв'язок.

В інформатиці евристичний алгоритм, або просто евристика — це алгоритм, спроможний видати прийнятне рішення проблеми серед багатьох рішень, але неспроможний гарантувати, що це рішення буде найкращим. Отже, такі алгоритми є приблизними і неточними. Зазвичай такі алгоритми знаходять рішення, близьке до найкращого і роблять це швидко. Іноді такий алгоритм може бути точним, тобто він знаходить дійсно найкраще рішення, але він все одно буде називатися евристичним доти, доки не буде доведено, що рішення дійсно найкраще. Один з найвідоміших — жадібний алгоритм, для того, щоб бути простим і швидким, цей алгоритм ігнорує деякі вимоги задачі.

Дві фундаментальні цілі в інформатиці — знаходження алгоритмів з імовірно найкращим часом виконання та з хорошою або оптимальною якістю. Евристичний алгоритм відмовляється від однієї або обох цих цілей; наприклад, він зазвичай знаходить дуже хороше рішення, але немає доказів, що рішення насправді не є поганим; або працює досить швидко, але не має гарантії, що він завжди видасть рішення.

Декілька евристичних методів використовуються антивірусним ПЗ для виявлення вірусів та іншого шкідливого ПЗ.

 Існує клас евристичних стратегій, названих метаалгоритмами, котрі часто використовують — наприклад, випадковий пошук. Такі алгоритми можуть бути застосовані до широкого кола завдань, при цьому хороші характеристики не гарантуються.

Задача комівояжера — NP-повна. Часто на ній проводять випробування нових підходів до евристичного скорочення повного перебору.

NP-повна задача (англ. NP-complete) — в теорії алгоритмів та теорії складності це задача, що належить до класу NP та всі задачі з класу NP можна звести до неї за поліноміальний час.

Клас складності NP (англ. Complexity class NP) — клас складності, до якого належать задачі, що можна розв'язати недетермінованими алгоритмами за поліноміальний час; тобто, недетермінованими алгоритмами в яких завжди існує шлях успішного обчислення за поліноміальний час відносно довжини вхідного рядка;
Мова L належить до класу NP (недетермінованих поліноміальних) якщо вона розпізнається недетермінованою машиною Тюрінга {\displaystyle M} M з поліноміальною часовою складністю T(n)

Алгоритмом з поліноміальним часом називається такий алгоритм, час роботи якого (тобто, кількість елементарних двійкових операцій, необхідних для його виконання на детермінованій машині Тюринга) на вхідному рядку довжиною  l обмежено згори деяким поліномом P(l)

Задачі, що можна розв'язати алгоритмом з поліноміальним часом належать до класу задач складності P.

Поліном:

c0 + c1x + c2x^2 + ... + cnx^n,
де ci - сталі коефіцієнти (константи), x - змінна

*** HashSet/HashMap and TreeSet/TreeMap

* HashSet -> HashMap - based implementation of Set
* TreeSet -> TreeMap - based implementation of  NavigableSet

* HashMap -> HashTable - based implementation of Map
* TreeMap -> Red-Black Tree - based implementation of NavigableMap 

***
How does the HashMap work ?
***

HashMap in Java works on hashing principle. It is a data structure which allows us to store object and retrieve it in constant time O(1) provided we know the key.

When we call put method, hashcode() method of the key object is called so that hash function of the map can find a bucket location to store value object, which is actually an index of the internal array, known as the table. 

Вирішення колізій:

Колізії. Два різних ключі при хешуванні дають однаковий індекс.
Birthday problem – говорить нам, що ми не можемо уникнути колізії (лише маючи квадратичний розмір пам’яті)
Coupon collector + load balancing – колізії рівномірно розподілені
Вихід … необхідно ефективно вирішувати колізії.

хеш-ф-я для 2 різних ключів повертає одне й те ж значення (одну комірку масиву)

1 Рішення: роздільне зв’язування (separate chaining)

Використовувати масив M<N зв’язних списків

Алгоритм:
Hash: отримати число int i між 0 і М-1
Insert: розмістити на початок і-того зв’язного списку (якщо вже не в ньому)
Search: шукаємо елемент в і-тому зв’язному списку

Since the internal array of HashMap is of fixed size, and if you keep storing objects, at some point of time hash function will return same bucket location for two different keys, this is called collision in HashMap. In this case, a linked list is formed at that bucket location and a new entry is stored as next node.

If we try to retrieve an object from this linked list, we need an extra check to search correct value, this is done by equals() method. Since each node contains an entry, HashMap keeps comparing entry's key object with the passed key using equals() and when it return true, Map returns the corresponding value.


2. Рішення: open addressing
Коли новий ключ отримує колізію (комріка вже зайнята) шукаємо наступну порожню комірку і розміщуємо значення в неї

3. Рішення: лінійне наближення (linear probing)

Алгоритм:
Hash: отримати число int i між 0 і М-1
Insert: розмістити в масив під індексом i якщо вільна, якщо ні спробувати і+1, і+2, …

Separate chaining:
легше реалізувати видалення
продуктивність падає поступово
кластеризація менш чутлива до погано розробленої хеш функції

Linear probing
менше змарнованого місця
простіше реалізувати кешування

Хеш таблиці:

простіше програмуються
немає іншої ефективнішої альтернативи для невпорядкованих ключів
швидкі для простих ключів (декілька арифметичних операцій, замість logN порівнянь)
краща системна підтримка в Java для стрічок 

Збалансовані дерева пошуку:

краща гарантія продуктивності
підтримка впорядкованих операцій
простіше реалізувати compareTo() чим equals() + hashCode()

Java включає реалізацію обох підходів:

Червоно-чорні збалансовані дерева: TreeMap, TreeSet
Хеш таблиці: HashMap, IdentityHashMap

* equals() and hashCode() contract  that two unequal objects in Java can have same hashcode.

To read:
Data Structures and Algorithm Analysis in Java (3rd Edition) 3rd Edition
by Mark A. Weiss (Author)

***
HashMap vs HashTable
***

Though both Hashtable and HashMap are data-structure based upon hashing and implementation of Map interface, the main difference between them is that HashMap is not thread-safe but Hashtable is thread-safe. Which means you cannot use HashMap in multi-threaded Java application without external synchronization. Another difference is HashMap allows one null key and null values but Hashtable doesn't allow null key or values. Also, thread-safety of the hash table is achieved using internal synchronization, which makes it slower than HashMap. By the way, difference between HashMap and Hashtable in Java is one of the frequently asked in core Java interviews to check whether the candidate understands correct usage of collection classes and aware of alternative solutions available.

Along with How HashMap internally works in Java and ArrayList vs Vector, this  is one of the oldest questions from Collection framework in Java. Hashtable is a legacy Collection class and it's there in Java API from a long time but it got refactored to implement Map interface in Java 4 and from there Hashtable became part of Java Collection framework.


Difference between HashMap and Hashtable in Java

Both HashMap and Hashtable implements Map interface but there is some significant difference between them which is important to remember before deciding whether to use HashMap or Hashtable in Java. Some of them are thread-safety, synchronization, and speed. here are those differences :

1.The HashMap class is roughly equivalent to Hashtable, except that it is non-synchronized and permits nulls. (HashMap allows null values as key and value whereas Hashtable doesn't allow nulls).

2. One of the major differences between HashMap and Hashtable is that HashMap is non-synchronized whereas Hashtable is synchronized, which means Hashtable is thread-safe and can be shared between multiple threads but HashMap can not be shared between multiple threads without proper synchronization. Java 5 introduces ConcurrentHashMap which is an alternative of Hashtable and provides better scalability than Hashtable in Java.

HashMap vs Hashtable in Java

3. Another significant difference between HashMap vs Hashtable is that Iterator in the HashMap is  a fail-fast iterator  while the enumerator for the Hashtable is not and throw ConcurrentModificationException if any other Thread modifies the map structurally  by adding or removing any element except Iterator's own remove() method. But this is not a guaranteed behavior and will be done by JVM on best effort. This is also an important difference between Enumeration and Iterator in Java.

4. One more notable difference between Hashtable and HashMap is that because of thread-safety and synchronization Hashtable is much slower than HashMap if used in Single threaded environment. So if you don't need synchronization and HashMap are only used by one thread, it outperforms Hashtable in Java.

5. HashMap does not guarantee that the order of the map will remain constant over time.

HashMap and Hashtable : note on Some Important Terms

1)Synchronized means only one Thread can modify a hash table at one point of time. Basically, it means that any thread before performing an update on a Hashtable will have to acquire a lock on the object while others will wait for the lock to be released.

2) Fail-safe is relevant from the context of iterators. If an Iterator or ListIterator has been created on a collection object and some other thread tries to modify the collection object "structurally", a concurrent modification exception will be thrown. It is possible for other threads though to invoke "set" method since it doesn't modify the collection "structurally". However, if prior to calling "set", the collection has been modified structurally, "IllegalArgumentException" will be thrown.

Difference between HashMap and Hashtable in Java




3) Structurally modification means deleting or inserting element which could effectively change the structure of the map.

HashMap can be synchronized by

Map m = Collections.synchronizeMap(hashMap);

In Summary, there are significant differences between Hashtable and HashMap in Java e.g. thread-safety and speed and based upon that only use Hashtable if you absolutely need thread-safety if you are running Java 5 consider using ConcurrentHashMap in Java.

***
What is difference between Enumeration and Iterator in Java?
***

Both Iterator and Enumeration provides way to traverse or navigate through entire collection in Java.

Between Enumeration and Iterator, Enumeration is older and its there from JDK1.0, while iterator was introduced later. Iterator can be used with ArrayList, HashSet and other collection classes.  Another similarity between Iterator and Enumeration in Java is that  functionality of Enumeration interface is duplicated by the Iterator interface.

1. Iterator also allows you to remove elements from collection during traversal but Enumeration doesn't allow that, it doesn't got the remove() method. 

2. Enumeration is also a legacy class and not all Collection supports it e.g. Vector supports Enumeration but ArrayList doesn't. 

3. Only major difference between Enumeration and iterator is Iterator has a remove() method while Enumeration doesn't. Enumeration acts as Read-only interface, because it has the methods only to traverse and fetch the objects, where as by using Iterator we can manipulate the objects like adding and removing the objects from collection e.g. Arraylist.

4. 
Also Iterator is more secure and safe as compared to Enumeration because it  does not allow other thread to modify the collection object while some thread is iterating over it and throws ConcurrentModificationException. This is by far most important fact for me for deciding between Iterator vs Enumeration in Java.


In Summary both Enumeration and Iterator will give successive elements, but Iterator is new and improved version where method names are shorter, and has new method called remove. Here is a short comparison:

Enumeration
hasMoreElement()
nextElement()
N/A


Iterator
hasNext()
next()
remove()

So Enumeration is used when ever we want to make Collection objects as Read-only.

*** 
Vector

differences between Vector and ArrayList
***

Unlike the new collection implementations, Vector is synchronized. If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector.

* Similarities between these two and why we can use ArrayList in place of Vector on certain scenario.

ArrayList vs Vector in Java1) Vector and ArrayList are index based and backed up by an array internally.
2) Both ArrayList and Vector maintains the insertion order of element. Means you can assume that you will get the object in the order you have inserted if you iterate over ArrayList or Vector.
3) Both Iterator and ListIterator returned by ArrayList and Vector are fail-fast.
4) ArrayList and Vector also allows null and duplicates.

Vector vs ArrayList in Java

Now let's see some key difference between Vector and ArrayList in Java, this will decide when is the right time to use Vector over ArrayList and vice-versa. Differences are based upon properties like synchronization, thread safety, speed, performance , navigation and Iteration over List etc.

1) Synchronization and thread-safety

First and foremost difference between Vector and ArrayList is that Vector is synchronized and ArrayList is not, what it means is that all the method which structurally modifies Vector e.g. add () or remove () are synchronized which makes it thread-safe and allows it to be used safely in a multi-threaded and concurrent environment. On the other hand ArrayList methods are not synchronized thus not suitable for use in multi-threaded environment. This is also a popular interview question on thread, where people ask why ArrayList can not be shared between multiple threads.

2) Speed and Performance

ArrayList is way faster than Vector. Since Vector is synchronized and thread-safe it pays price of synchronization which makes it little slow. On the other hand ArrayList is not synchronized and fast which makes it obvious choice in a single-threaded access environment. You can also use ArrayList in a multi-threaded environment if multiple threads are only reading values from ArrayList or you can create read only ArrayList as well.

3) Capacity

Whenever Vector crossed the threshold specified it increases itself by value specified in capacityIncrement field while you can increase size of ArrayList by calling ensureCapacity () method.
4) Enumeration and Iterator

Vector can return enumeration of items it hold by calling elements () method which is not fail-fast as opposed to Iterator and ListIterator returned by ArrayList. I have discussed this point in detail on my post What is difference between Iterator and Enumeration, you can also look there.

5) Legacy

Another point worth to remember is Vector is one of those classes which comes with JDK 1.0 and initially not part of Collection framework but in later version it's been re-factored to  implement List interface so that it could become part of collection framework

After considering these points about both Vector and ArrayList , my conclusion is use ArrayList wherever possible and avoids use of Vector until you have no choice. Think for CopyOnWriteArrayList  over Vector, if you have multiple readers and few writers because it can provide thread-safety without impacting performance too much.

***
Difference between LinkedList vs ArrayList in Java
***

Main difference between ArrayList and LinkedList is that ArrayList is implemented using re sizable array while LinkedList is implemented using doubly LinkedList. ArrayList is more popular among Java programmer than LinkedList as there are few scenarios on which LinkedList is a suitable collection than ArrayList. 

LinkedList vs ArrayList in Java

Difference between LinkedList and ArrayList in JavaAll the differences between LinkedList and ArrayList has there root on difference between Array and LinkedList data-structure. If you are familiar with Array and LinkedList data structure you will most likely derive following differences between them:

1) Since Array is an index based data-structure searching or getting element from Array with index is pretty fast. Array provides O(1) performance for get(index) method but remove is costly in ArrayList as you need to rearrange all elements. On the Other hand LinkedList doesn't provide Random or index based access and you need to iterate over linked list to retrieve any element which is of order O(n).

2) Insertions  are easy and fast in LinkedList as compared to ArrayList because there is no risk of resizing array
and copying content to new array if array gets full which makes adding into ArrayList of O(n) in worst case, while adding is O(1) operation in LinkedList in Java. ArrayList also needs to update its index if you insert something anywhere except at the end of array.

3) Removal is like insertions better in LinkedList than ArrayList.

4) LinkedList has more memory overhead than ArrayList because in ArrayList each index only holds actual object (data) but in case of LinkedList each node holds both data and address of next  and previous node.

Існує дві основні різновиди List:
Базовий контейнер ArrayList, оптимізований для довільного доступу до елементів, але з відносно повільними операціями вставки(видалення) елементів в середині списку.

Контейнер LinkedList, оптимізований для послідовного доступу, з швидкими операціями вставки (видалення) у середині списку;
Довільний доступ до елементів LinkedList виконується відносно повільно, але по широті можливостей він перевершує ArrayList.

When to use LinkedList and ArrayList in Java

As I said LinkedList is not as popular as ArrayList but still there are situation where a LinkedList is better choice than ArrayList in Java. Use LinkedList in Java if:

1) Your application can live without Random access. Because if you need nth element in LinkedList you need to first traverse up to nth element O(n) and than you get data from that node.

2) Your application is more insertion and deletion driver and you insert or remove more than retrieval. Since insertion or
removal doesn't involve resizing its much faster than ArrayList.

That’s all on difference between ArrayList and LinkedList in Java. Use ArrayList in Java for all there situation where you need a non-synchronized index based access. ArrayList is fast and easy to use, just try to minimize array resizing by constructing arraylist with proper initial size.

***
Difference between List and Set in Java Collection
***


1) Fundamental difference between List and Set in Java is allowing duplicate elements. List in Java allows duplicates while Set doesn't allow any duplicate. If you insert duplicate in Set it will replace the older value. Any implementation of Set in Java will only contains unique elements.

2) Another significant difference between List and Set in Java is order. List is an Ordered Collection while Set is an unordered Collection. List maintains insertion order of elements, means any element which is inserted before will go on lower index than any element which is inserted after. Set in Java doesn't  maintain any order. Though Set provide another alternative called SortedSet which can store Set elements in specific Sorting order defined by Comparable and Comparator methods of Objects stored in Set.

3) Set uses equals() method to check uniqueness of elements stored in Set, while SortedSet uses compareTo() method to implement natural sorting order of elements. In order for an element to behave properly in Set and SortedSet, equals and compareTo must be consistent to each other.

4) Popular implementation of List interface in Java includes ArrayList, Vector and LinkedList. While popular implementation of Set interface includes HashSet, TreeSet and LinkedHashSet.

When to use List and Set in Java:

its pretty clear that if you need to maintain insertion order or object and you collection can contain duplicates than List is a way to go. On the other hand if your requirement is to maintain unique collection without any duplicates than Set is the way to go.

Important point to note is that both List and Set are derived from Collection Interface. In short main difference between List and Set in Java is that List is an ordered collection which allows duplicates while Set is an unordered collection which doesn't allow duplicates.



