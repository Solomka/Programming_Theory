***
OOD (Object-oriented design) is about:
***
- dependencies (to know)
- responsibilities (to do )
- evristics (best solution/practice of solution):
  В інформатиці евристичний алгоритм, або просто евристика — це алгоритм, спроможний видати прийнятне рішення проблеми серед багатьох рішень, але не спроможний гарантувати, що це рішення буде найкращим.
  Отже, такі алгоритми є приблизними і неточними. Зазвичай такі алгоритми знаходять рішення, близьке до найкращого і роблять це швидко. Іноді такий алгоритм може бути точним, тобто він знаходить дійсно найкраще рішення, але він все одно буде називатися евристичним доти, доки не буде доведено, що рішення дійсно найкраще. 
  * Жадібний алгоритм
        Жа́дібний алгори́тм — простий і прямолінійний евристичний алгоритм, який приймає найкраще рішення, виходячи з наявних на поточному етапі даних, не турбуючись про можливі наслідки, сподіваючись врешті-решт отримати оптимальне рішення.

        Зазвичай, жадібний алгоритм базується на п'яти принципах:

Набір можливих варіантів, з яких робиться вибір;
Функція вибору, за допомогою якої знаходиться найкращий варіант;
Функція придатності, яка визначає придатність отриманого набору;
Функція цілі, оцінює цінність рішення, не виражена явно;
Функція розв'язку, яка вказує на те, що знайдене кінцеве рішення.

            Наприклад, використання жадібної стратегії для задачі комівояжера породжує наступний алгоритм: «На кожному етапі вибирати найближче з невідвіданих міст».

            Зада́ча комівояже́ра (комівояжер — бродячий торговець; англ. Travelling Salesman Problem, TSP; нім. Problem des Handlungsreisenden) полягає у знаходженні найвигіднішого маршруту, що проходить через вказані міста хоча б по одному разу. В умовах завдання вказуються критерій вигідності маршруту (найкоротший, найдешевший, сукупний критерій тощо) і відповідні матриці відстаней, вартості тощо. Зазвичай задано, що маршрут повинен проходити через кожне місто тільки один раз, в такому випадку розв'язок знаходиться серед гамільтонових циклів.

            Прості методи розв'язання задачі комівояжера: повний лексичний перебір, жадібні алгоритми (метод найближчого сусіда), метод включення найближчого міста, метод найдешевшого включення, метод мінімального кістяка дерева. На практиці застосовують різні модифікації ефективніших методів: метод гілок і меж і метод генетичних алгоритмів, а так само алгоритм мурашиної колонії.

            Всі ефективні (такі, що скорочують повний перебір) методи розв'язання задачі комівояжера — евристичні. У більшості евристичних методів знаходиться не найефективніший маршрут, а наближений розв'язок. Користуються популярністю так звані any-time алгоритми, тобто алгоритми, що поступово покращують деякий поточний наближений розв'язок.

            Задача комівояжера — NP-повна. Часто на ній проводять випробування нових підходів до евристичного скорочення повного перебору.

  ***
  Fine design = GoF + GRASP + SOLID =/=> to avoid Design Smells
  ***

  * RDP (Responsibility Driven Design)
    - Відповідальності (responsibilities)
      Знати (dependency)
      Робити (responsibility)
    - Ролі (roles) 
    - Взаємодія (collaboration)
  * LRP (Law Representationl Gap)

  ***
  Design Smells
  ***
  
 * Жорсткість (rigidity) - порушення High cohesion (зміни в одному класі => зміни в інших класа => Висока звязАність коду)
 * Крихкість (fragility)
 * Нерухомість (immobility)
 * В’язкість (viscosity)
 * Надлишкова складність (needless complexity)
 * Надлишкова повторюваність (needless repetition)
 * Непрозорість (opacity)

 ***
 GRASP (General Responsibility Assigning Design Patterns / General Design Patterns of Responsibility Assigning )
 ***
 -------
 * abstract principles
 * domain modelling
 -------
  * Creator
  * Information Expert (Repository -> Factory/Builder....)
  * Low Coupling (низька звязАність)
  * High Cohesion (висока звязність)
  * Controller
  * Polymorphism
  * Pure Fabrication:
   - GoF (Design patterns)
   - Conroller
   - Interface
   - Abstract class
   - Service
  * Indirection (Interface)
  * Protected Variations

  ***
  SOLID (Robert C. Martin "Uncle Bob")
  ***
  ------
  * code realisation of abstract principles GRASP
  ------

  * SRP (Single Responsibility Principle) 
    => В класі (компоненті) може існувати одна і тільки одна причина для зміни

  * OCP (Open-closed)
    => Класи повинні бути відкритими для розширення і закритими для змін

  * LSP (Liscov substitution) 
    => Базові типи повинні бути замінювані своїми підтипами

  * ISP (Interface Segregation)
    => Клієнти не повинні залежати від методів, які вони не використовують
    => Різні клієнти – різні інтерфейси

  * DIP (Dependency Inversion)
    => Модулі вищого рівня не повинні залежати від модулів нижчого рівня. І ті, і інші повинні залежати від абстракцій.
    => Абстракції не повинні залежати від деталей. Деталі повинні залежати від абстракцій.
