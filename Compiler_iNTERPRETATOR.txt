Мова над алфавитом   

Мова (формальна) над алфавитом  – множина ланцюжків(слів, що склажаються з символів алфавіту)в , не обов’язково скінчена.

Граматика – математичний об’єкт для візначення мови.

 Використовуються два  алфавіта(не перетинаються):
N – множина нетермінальних символів.
 - множина термінальних символів, з яких утворюються слова або ланцюжки мови.

Правило підстановки (продукція, аксіома) – впорядкована пара ланцюжків виду:
                       xy, 

Породжуюча граматика мови  - це  четвірка 

             G = (N, , S,R),

 де N - алфавіт нетермінальних символіа
    Е - множине термінальих символів
    S - початковий символ алфавіту
    R - множина продукцій (правил виводу)

Приклад:

        G=({A, S}, {0,1}, S, R )                      
        R: S->1A00                    
            A0->0A1              
             A->е
        L(G)={100, 1010} - мова (множина слів не обовязково скінченна), породжена граматикою

Мова L(G), породжена граматикою G, – це  множина 

                    L(G) = {w | S * w},    
  де w*.


Класифікація формальних мов Наома Хомського: ( ієрархією Хомського )

*************************************************************************

https://uk.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%96%D0%BB%D1%8F%D1%82%D0%BE%D1%80

       Лексичний аналіз      vs          Синтаксичний аналіз
Лексичний аналізатор (сканер)      Синтаксичний аналізатор (парсер)

Задача лексичного аналізатора – виокремити лексеми токенів і повідомити синтаксичний аналізатор про тип токена та його лексичне значення.
Задача синтаксичного аналізатора – встановити шлях, яким вхідна програма виводиться з стартового символу (побудова дерева розбору).
Семантичний аналіз — перевірка відповідності правилам вхідної мови та побудова таблиці символів.


***
Лексичний аналіз
***

Лексичний аналіз - процес перетворення послідовності лексем у послідовність токенів
лексичний аналіз використовують для підсвітки синтаксису певних мов.

Лексичний аналізатор є скінченним автоматом, перехід в певні стани якого викликає функції, які зазвичай повертають тип/клас лексеми, і саму лексему.

Процес утворення позначок (токенів) з вихідного потоку називається видобуванням позначок (англ. tokenization) і аналізатор впорядковує їх за відповідними типами. 
Лексичний аналізатор зазвичай нічого не робить з об'єднаннями позначок (послідовінстю токенів), це завдання припадає на синтаксичний аналізатор.
Наприклад, типовий лексичний аналізатор розпізнає дужки як лексеми, але перевіряє відповідність '(' і ')' дужок.


Лексема (слово) — послідовність машинних символів вихідного коду програми, що мають певне сукупне значення.

Класи лексем (Шаблон токена )

зарезервовані слова
ідентифікатори
числові константи
(цілі та дійсні числа)

літерні константи
рядкові константи
коди операторів
коментарі, які безпосередньо не несуть інформації щодо структури програми; транслятором не сприймаються, синтаксичному аналізатору не передаються.
дужки й інші елементи програми.

Токен — об'єкт, що утворюється із лексеми в процесі лексичного аналізу.
Шаблон токена — формальний опис класу лексем, які можуть утворити даний тип токена.

Послідовність машинних символів, що утворюють токен, називають лексемою токена. Токени мають тип (наприклад, ідентифікатор, числова стала — це типи токенів). Деякі токени мають лексичне значення (наприклад, значення числової чи рядкової константи утвореної з лексеми токена). Задача лексичного аналізатора – виокремити лексеми токенів і повідомити синтаксичний аналізатор про тип токена та його лексичне значення.

тип токена  приклади лексем  опис (шаблон токена)
string  "Мова \"C\" "    рядкова стала
id  Name01  ідентифікатор
relop   >=  операції відношення
num 13  число

Lexem: мама Type (Клас): слово

Наступним кроком іде синтаксичний аналіз.
Звідти, витрактовані дані можуть бути завантажені в структури даних для загального використання, інтерпретації, компіляції.

***
Синтаксичний аналіз
***

Синтаксичним аналізом (па́рсинг) (англ. parsing) (розбором) називається процес, що визначає,  чи породжується даний рядок лексем даною формальною граматикою (чи належить лексема даній мові, яка породжується даною, зазвичай, контекстно-вільною граматикою).

Виконання синтаксичного аналізу здійснюється розпізнавачами (автоматами) (синтаксичними аналізторами).
Синтаксичний аналіз дає відовідь на запитання: чи належить аналізований ланцюжок машинних символів (лексема) множині правильних ланцюжків (лексем) заданої мови. 

Під час синтаксичного аналізу текст оформлюється у структуру даних, зазвичай — в дерево розбору, яке відповідає синтаксичній структурі вхідної послідовності, і добре підходить для подальшої обробки.
Зазвичай синтаксичні аналізатори працюють в два етапи:
     на першому  - ідентифікуються осмислені токени (виконується лексичний аналіз)
                 - на другому створюється дерево розбору.

Найчастіше парсери використовуються для розбору тексту вихідного коду комп'ютерних мов програмування.
Комп'ютерні мови програмування мають відносно просту граматику з невеликою кількістю виключень. 
Парсер мови програмування зазвичай заснований на контекстно-вільній граматиці, оскільки на її основі можна написати простий та ефективний парсер.

Ієрархічний аналіз називається розбором (англ. parsing) чи синтаксичним аналізом, у ході якого відбувається групування токенів програми. В синтаксичному аналізі символом називають токени (термінали) та групи токенів об'єднаних у логічне ціле в процесі аналізу (нетермінали).

Синтаксис звичайно визначається контекстно-незалежною граматикою, що складається з символів – терміналів та нетерміналів, стартового символу що належить множині нетерміналів, та контесктно-незалежних продукцій.

Основна ідея Хомського полягала в тому,що семантика(смисл) речення мови пов’язана з  його синтаксичною структурою.
Структура  задається продукціями граматики, яка породжує мову, і представляє собою ієрархічне розбиття об’єкта на пов’язані між собою частини 

Синтаксичний аналізатор(СА)  може бути побудований для будь-якої граматики. Але найбільш ефективні аналізатори будуються для КВ граматик.

Синтаксичний аналізатор (англ. parser) — це програма або частина програми, яка виконує синтаксичний аналіз.

***

Лесичний аналізатор (сканер) (для підсвітки синтаксису мов програмування) => 
                        Lexem: , Lexem class: розділовий знак

Синтаксичний аналізатор (парсер) (для розбору тексту вихідного коду комп'ютерних мов програмування) => 


******************************************************************************************

***

Компілятор (англ. Compiler від англ. to compile збирати в ціле) — комп'ютерна програма (або набір к. програм), що перетворює (компілює) вихідний код, написаний певною мовою програмування (мова джерела, англ. source language), на семантично еквівалентний код в іншій мові програмування (мова цілі, англ. target language), який, як правило, необхідний для виконання програми машиною, наприклад, комп'ютером.

Коротко компілятор можна визначити, як програму або технічний засіб, що виконує компіляцію.

Історично компілятором називалась програма що зв'язувала підпрограми, чим й зумовлено походження слова. Сьогодні це завдання виконує компонувальник.

Для виконання програма не завжди повинна бути перекладена компілятором, існує також інший принцип: покрокове виконання програмних інструкцій інтерпретатором.

Процес компіляції:

Процес, у якому компілятор читає програму записану початковою мовою і записує цільовою мовою називають компіляцією (трансляцією, перекладом). В залежності від типу компілятора та налаштувань, цей процес може бути як простим однопрохідним зчитуванням та записом результату, так і розгалуженою багатокроковою ресурсомісткою обробкою та аналізом вхідного коду для численних оптимізацій та налаштувань.

Загалом компіляцію поділяють на наступні послідовні і залежні кроки:

Аналіз (front-end) – зчитування та розбиття початкової програми на складові частини для створення проміжного представлення.
    Лексичний аналіз — на цьому етапі послідовність символів сирцевого файлу перетвориться в послідовність лексем.
    Синтаксичний аналіз, під час якого послідовність лексем перетвориться в дерево розбору.
    Семантичний аналіз — перевірка відповідності правилам вхідної мови та побудова таблиці символів.
Генератор проміжного коду, будує проміжне представлення для подальших оптимізацій.
Синтез (back-end) – побудова цільової програми на базі проміжного представлення.
    Попередній аналіз проміжного представлення на залежності, потік даних та інші контекстні властивості, важливі для оптимізації.
    Оптимізація – покращення для швидкодії, розміру, паралелізму тощо.
    Генератор цільового коду створює кінцевий результат роботи компілятора – цільову програму.

У конкретних реалізаціях компіляторів ці етапи можуть бути розділені або, навпаки, поєднані в тому чи іншому вигляді.

Початкова мова визначається її синтаксисом – описом того, з яких конструкцій складається мова, та семантикою – набором правил, що визначають суть цих конструкцій.

Поширені стратегії компіляції:

    Компіляція перед виконанням (англ. AOT, ahead-of-time). Класичний принцип, коли компіляція проводиться окремо від виконання, зазвичай у відмінному від місця виконання середовищі. Компілятори мов програмівання Pascal, C, C++, BASIC, Fortran, COBOL використовують стратегію такої попередньої компіляції.
    Компіляція під час виконання (англ. JIT, just-in-time), відома також як динамічна компіляція. Суть полягає у компіляції часу виконаня (англ. run time), коли текст вхідної мови перетворюється у машинний код на льоту и тут же виконується. Ця техніка поєднує у собі методи як попередньої компіляції у проміжний код так і інтерперетації цього проміжного коду під час виконання. Будучи більш продвинутою технікою, компіляція на льоту має досить жорсткі вимоги до простоти компіляції, і не є доцільною для певних мов програмування.[9] Принциповим представником JIT компіляції є середовище виконання мови Java, піонером же вважається Smalltalk.
    Транскомпіляція, або компіляція з однєї високорівневої мови в іншу (англ. source-to-source). Принциповою відмінністю даної стратегії є те, що як вхідний так і вихідний код є мовами програмування високого рівня. Типовими прикладами використання є підготовка коду для паралельної оптимізації, перекомпіляція старішого коду для нової версії стандарту мови програмування, компіляція мов-надбудов у базову мову. Представниками таких мов програмування є CoffeeScript[10], Dart, Haxe, Coccinelle[11].
    Перекомпіляція – динамічна компіляція частин програми під час виконання (англ. dynamic recompilation). Особливість деяких серед виконання – емуляторів та віртуальних машин, перекомпільовувати деяку частину програми під час її роботи. Ця техніка використовується для переносу коду на їншу архітекутуру під час його виконання, зокрема для запуску застарілих програм на сучасних операційних системах. Широко використовується Java run time[12] та .Net Common Language Runtime[13], а також багатьма віртуальними машинами.

***

Інтерпретатор мови програмування (interpreter) — програма чи технічні засоби, необхідні для виконання інших програм, вид транслятора, який здійснює пооператорну (покомандну, построкову) обробку, перетворення у машинні коди та виконання програми або запиту (на відміну від компілятора, який транслює у машинні коди всю програму без її виконання).

Інтерпретатори можуть працювати як з сирцевим кодом програми (англ. source code), написаним мовою програмування, так і з байт-кодом (інтерпретатори байт-коду).

Інтерпретатор мови програмування (interpreter) — програма чи технічні засоби, необхідні для виконання інших програм, вид транслятора, який здійснює пооператорну (покомандну, построкову) обробку, перетворення у машинні коди та виконання програми або запиту (на відміну від компілятора, який транслює у машинні коди всю програму без її виконання). Типи інтерпретаторів[ред. • ред. код]
Простий інтерпретатор аналізує і відразу виконує (власне інтерпретація) програму покомандно (або порядково), по мірі надходження її сирцевого коду на вхід інтерпретатора. Перевагою такого підходу є миттєва реакція. Недолік - такий інтерпретатор виявляє помилки в тексті програми тільки при спробі виконання команди (або рядка) з помилкою.

Інтерпретатор компілюючого типу - це система з компілятора, який перекладає сирцевий код програми в проміжне представлення, наприклад, в байт-код або p-код, і власне інтерпретатора, який виконує отриманий проміжний код (так звана віртуальна машина). Перевагою таких систем є більша швидкодія виконання програм (за рахунок винесення аналізу сирцевого коду в окремий, разовий прохід, і мінімізації цього аналізу в інтерпретаторі). Недоліки - більші вимоги до ресурсів і вимога на коректність сирцевого коду. Застосовується в таких мовах, як Java, Tcl, Perl (використовується байт-код), REXX (зберігається результат парсинга сирцевого коду), а також у різних СУБД (використовується p-код).

Інтерпретатор компілюючого типу складається з компілятора мови і простого інтерпретатора з мінімізованим аналізом сирцевого коду. Сирцевий код для такого інтерпретатора не обов'язково повинен мати текстовий формат, це може бути машинний код якоїсь існуючої апаратної платформи.
 Наприклад, віртуальні машини типу QEMU, Bochs, VMware включають в себе інтерпретатори машинного коду процесорів сімейства x86.

Деякі інтерпретатори (наприклад, для мов Lisp, Scheme, Python, Basic та інших) можуть працювати в режимі діалогу або так званого циклу читання-обчислення-друку (англ. read-eval-print loop, REPL). У такому режимі інтерпретатор зчитує закінчену конструкцію мови (наприклад, s-expression у мові Lisp), виконує її, друкує результати, після чого переходить до очікування введення користувачем наступної конструкції.

***

Трансля́тор (англ. translator) — програма або технічний засіб, який виконує перетворення чи іншу обробку текстів програм.

Транслятори поділяються на:

компілятори — перетворюють текст програми мови високого рівня в об'єктний код чи байт-код.
декомпілятори — навпаки, намагаються з машинного коду отримати початковий код на високорівневій мовах.
асемблери — перетворюють текст програми мови асемблера в машинний код.
дизасемблери — навпаки, намагаються розшифрувати машинний код.
інтерпретатори — отримують текст програми та набір вхідних даних, і повертають результат виконання програми над вхідними даними.
препроцесори — отримують текст програми, і повертають перетворений певним чином текст програми.[Джерело?]
Оскільки компілятори та інтерпретатори реалізують мови програмування, вони мають спільні риси: їх структура досить схожа, в основу їх реалізації покладено спільні теоретичні результати та практичні методи реалізації.